#pragma once
#include "Std.h"

class Bitmap
{
public:
	bool				Init();
	bool				Frame();
	bool				Render();
	bool				Release();
	bool				LoadFile(T_STR);
	HBITMAP				getHBITMAP();
	HDC					getMemDC();
	BITMAP				getBitmapInfo();
public:
	void * operator new(size_t sz, const char* FileName, int iLine);
	void operator delete(void * p);
private:
	BITMAP				m_BitmapInfo;
	HBITMAP				m_hBitmap;
	HDC					m_hMemDC;
};#pragma once
#include "Bitmap.h"

struct CacheData_
{
	T_STR	m_tName;
	Bitmap* m_bBitmap;
};


class BitmapMgr : public Singleton<BitmapMgr>
{
	friend class Singleton<BitmapMgr>;
public:
	BitmapMgr();
	~BitmapMgr();
public:
	bool						Init();
	bool						Frame();
	bool						Render();
	bool						Release();
public:
	T_STR						LoadFile(T_STR, T_STR);
	Bitmap*						getBitmapPtr(T_STR);
private:
	void						AddCache(T_STR, Bitmap*);
private:
	std::map<T_STR, Bitmap*>	m_BitmapList;
	std::list<CacheData_>		m_CacheList;
};

#define S_BitmapMgr	BitmapMgr::getInstance()#pragma once
#include "CharacterObject.h"
#include "UI.h"

class TerrainObject;
class PlatObject;

class BKObject : public Object
{
public:
	BKObject();
public:
//	bool		Init			() override;
	bool		Frame			() override;
	bool		Render			() override;
	bool		Release			() override;
	bool		MoveScrollBk	(const LONG&) override;
	void		AddTerrain		(TerrainObject *);
	void		AddPlat			(PlatObject *);
	void		AddUI			(UI* ui);
	bool		Collision		(Object* ) override;
	void		ReverseSet		();
	void		PlatUp			();
	bool		isPlatUp		();
private:
	std::vector<TerrainObject*> m_pObjList;
	std::vector<PlatObject*>	m_pPlatList;
	std::vector<UI*>			m_pUIList;
};#pragma once
#include "FinateStateMachine.h"
#include "EffectObj.h"


class State;
using StateMap = std::map<std::string, State*>;
using EffectVector = std::vector<EffectObj*>;
using EffectIter = EffectVector::iterator;

class CharacterObject : public Object
{
public:
	CharacterObject();
public:
	virtual bool 		Init			() override;
	virtual bool 		Frame			() override;
	virtual bool 		Render			() override;
	virtual bool 		Release			() override;
public:
	void				setState		(T_STR);
	void				setDir			(const INT&);
	void				setLadder		(const bool&);
	void				setJumpSpeed	(const FLOAT&, const FLOAT& = 0.0f);
	void				setJumpNum		(const INT&);
	void				setDownable		(const bool&);
	virtual void		setHP			(const INT&);
	void				setInvincible	(const bool&);
	void				setDead			(const bool&);
	void				setFSM			(FinateStateMachine* );
	void				setDamage		(const INT&);
public:
	bool				isInvincible	();
	bool				isDead			();
	INT					getDamage		();
	RECT				getEffectObj	();
	std::string			getCurrentState	();
	bool				getDownable		();
	INT					getDir			();
	FLOAT&				getJumpSpeed	(const INT& = 0);
	bool				getLadder		();
	INT					getJumpNum		();
	FLOAT				getZoom			();
	INT					getHP			();
	virtual bool		isFallState		();
public:
	void				addState		(std::string, State*);
	void				addEffect		(EffectObj *);
public:
	bool				hasNext();
	void				deleteEffect	(EffectIter&);
	EffectIter			getEffectIter	();
public:
	std::string			setTransition	(E_EVENT Event);
protected:
	FLOAT				m_fZoom;
	bool				m_bDead;
	INT					m_HP;
	INT					m_Damage;
	INT					m_iJumpNumber;
	bool				m_bInvincible;
	bool				m_bLadder;
	bool				m_bDownable;
	FLOAT				m_fInvincibleTime;
	const FLOAT			m_finvencible;
	FLOAT				m_fJumpSpeed;
	FLOAT				m_fJumpSpeed2;
	INT					m_iCurrentDir;
	std::string			m_sCurrestState;
	State *				m_pCurrentState;
	StateMap			m_pStateList;
	EffectVector		m_pEffectVector;
	EffectIter			m_EffectIter;
	FinateStateMachine*	m_fms;
};#pragma once
#include "Std.h"

class CollisionClass
{
public:
	static bool					RectInPt(RECT, POINT);
	static bool					RectInRect(RECT, RECT);
	static bool					RectInRect(RECT, FloatRect);
	static bool					SphereInPt(RECT, POINT);
	static bool					SphereInSphere(RECT, RECT);
private:
};#pragma once
#include "wClass.h"
#include "Timer.h"
#include "Input.h"
class Core : public Window
{
public:
	virtual bool			GameInit() override;
	virtual bool			GameFrame() override;
	virtual bool			GameRender() override;
	virtual bool			GameRelease() override;
	virtual bool			Init() override;
	virtual bool			Frame() override;
	virtual bool			Render() override;
	virtual bool			Release() override;
private:
	bool					GamePreRender();
	bool					GamePostRender();
private:
	bool					FrameShow;
	HDC						m_hOffScreenDC;
	HDC						m_hScreenDC;
	Timer					m_Timer;
};#pragma once
#include "TerrainObject.h"

class DownableObject : public TerrainObject
{
public:
	bool		Collision(Object*) override;
	bool		MoveObject(Object*, const RECT&) override;
};#pragma once
#include "Object.h"
#include "SpriteMgr.h"

class EffectObj : public Object
{
public:
	virtual bool		Init		();
	virtual bool		Frame		();
	void				setSpeed	(const FLOAT&);
	void				setDrawPos	(const FloatPoint&);
	void				setIndex	(const int&);
public:
	void * operator new(size_t sz, const char* FileName, int iLine);
	void operator delete(void * p);
protected:
	Sprite *			m_pEffectSprite;
};#pragma once
#include "CharacterObject.h"
#include "EnemyBasicState.h"


class Player;

class Enemy : public CharacterObject
{
public:
	Enemy();
	~Enemy();
public:
	bool			Init		() override;
	bool			Frame		() override;
	bool			Render		() override;
	bool			isFallState	() override;
	bool			Process		(Player * pObject);
public:
	FloatRect*		getArea();
	FloatRect*		getSight();
	FloatRect*		getAttackRange();
public:
	void			setArea(const FloatRect&);
	void 			setSight(const FloatRect&);
	void 			setAttackRange(const FloatRect&);
	void			setJumpSpeed(const FLOAT&);
public:
	bool			MoveScrollObj(const LONG&) override;
private:
	FloatRect		m_rtArea;
	FloatRect		m_rtSight;
	FloatRect		m_rtAttackRange;
};#pragma once
#include "State.h"
#include "Collision.h"

class EffectObj;
class Enemy;
class Player;

class EnemyBasicState : public State
{
public:
	EnemyBasicState(Enemy*);
public:
	virtual bool		Init() = 0;
	virtual bool		Process(Player *) = 0;
	virtual bool		Render() override;
	bool				Release();
protected:
	Enemy *				m_pEnemy;
	FloatRect*			m_rtArea;
	FloatRect*			m_rtSight;
	FloatRect*			m_rtAttackRange;
};

class EnemyMoveState : public EnemyBasicState
{
public:
	EnemyMoveState(Enemy*);
public:
	bool				Init	() override;
	bool				Process	(Player *) override;
};
class EnemyChaseState : public EnemyBasicState
{
public:
	EnemyChaseState(Enemy*);
public:
	bool				Init() override;
	bool				Process(Player *) override;
};
class EnemyAttackState : public EnemyBasicState
{
public:
	EnemyAttackState(Enemy*);
public:
	bool				Init() override;
	bool				Process(Player *) override;
};

class EnemyHitState : public EnemyBasicState
{
public:
	EnemyHitState(Enemy*);
public:
	bool				Init() override;
	bool				Process(Player *) override;
};

class EnemyAngryState : public EnemyBasicState
{
public:
	EnemyAngryState(Enemy*);
public:
	bool				Init() override;
	bool				Process(Player *) override;
};

class EnemyMoveLocationState : public EnemyBasicState
{
public:
	EnemyMoveLocationState(Enemy*);
public:
	bool				Init() override;
	bool				Process(Player *) override;
};#pragma once
#include "Object.h"

class FadeObject : public Object
{
public:
	FadeObject();
	~FadeObject();
public:
	virtual bool		Init();
	virtual bool		Frame();
	virtual bool		Render();
	virtual bool		Release();
	bool				SetAlpha(const FLOAT&);
	bool				Decrease(const FLOAT&);
private:
	BLENDFUNCTION		m_bBlend;
	FLOAT				m_fAlpha;
	FLOAT				m_fDecrement;
	HDC					m_hMemDC;
	HBRUSH				m_bkBrush;
	HBITMAP				m_hOffBitmap;
};#pragma once
#include "EnemyBasicState.h"

enum class E_EVENT : unsigned char
{
	FINDTARGET,
	LOSTTARGET,
	BEATTACKED,
	BEARROWATTACKED,
	NOHIT,
	INATTACKRANGE,
	OUTATTACKRANGE,
	ARRIVE
};

class FinateState;

using EnemyOutputMap = std::map<E_EVENT, std::string>;
using EnemyMapState = std::map<std::string, FinateState*>;
using EnemyIterator = EnemyMapState::iterator;

class FinateState
{
public:
	FinateState();
public:
	void AddTransition			(const E_EVENT&, const std::string&);
	std::string GetState		(const E_EVENT&);
	void * operator new			(size_t sz, const char* FileName, int iLine);
	void operator delete		(void * p);
private:
	EnemyOutputMap m_mapOutput;
};

class FinateStateMachine
{
public:
	FinateStateMachine();
	~FinateStateMachine();
public:
	void AddStateTransition		(const std::string&, const E_EVENT&, const std::string&);
	std::string StateTransition	(const std::string&, const E_EVENT&);
	void * operator new			(size_t sz, const char* FileName, int iLine);
	void operator delete		(void * p);
private:
	EnemyMapState m_mapState;
};#pragma once
#include "FinateStateMachine.h"

using FSMList = std::map<T_STR, FinateStateMachine*>;

class FSMMgr : public Singleton<FSMMgr>
{
	friend class Singleton<FSMMgr>;
public:
	FSMMgr();
	~FSMMgr();
public:
	bool					Init			();
	bool					Frame			();
	bool					Render			();
	bool					Release			();
public:
	T_STR					LoadFile		(T_STR, T_STR);
	FinateStateMachine*		getFSMPtr		(T_STR);
private:
	FSMList					m_FSMMapList;
};

#define S_FSMMgr	FSMMgr::getInstance()#pragma once
#include "Scene.h"

class GameScene : public Scene
{
public:
	GameScene();
public:
	virtual bool		Init		() override = 0;
	virtual bool		Frame		() override = 0;
	virtual bool		Render		() override = 0;
	virtual bool		Release		() override = 0;
	virtual bool		inverseSet	() override = 0;
protected:
	Scroll				m_pScroll;
	std::list<Enemy*>	m_NPCList;
};

using NPCLIST = std::list<Enemy*>::iterator;

class GameScene1 : public GameScene
{
public:
	GameScene1();
public:
	bool				Init		() override;
	bool				Frame		() override;
	bool				Render		() override;
	bool				Release		() override;
	bool				inverseSet	() override;
};

class GameScene2 : public GameScene
{
public:
	GameScene2();
public:
	bool				Init		() override;
	bool				Frame		() override;
	bool				Render		() override;
	bool				Release		() override;
	bool				inverseSet	() override;
};

class GameScene3 : public GameScene
{
public:
	GameScene3();
public:
	bool				Init		() override;
	bool				Frame		() override;
	bool				Render		() override;
	bool				Release		() override;
	bool				inverseSet	() override;
};
class GameScene4 : public GameScene
{
public:
	GameScene4();
public:
	bool				Init		() override;
	bool				Frame		() override;
	bool				Render		() override;
	bool				Release		() override;
	bool				inverseSet	() override;
};

class GameScene5 : public GameScene
{
public:
	GameScene5();
public:
	bool				Init() override;
	bool				Frame() override;
	bool				Render() override;
	bool				Release() override;
	bool				inverseSet() override;
public:
	static FadeObject *	m_fDeadScene;
};#pragma once
#include "TerrainObject.h"

class GroundObject : public TerrainObject
{
public:

private:
};#pragma once
#include "Std.h"

class Input : public Singleton<Input>
{
	friend class Singleton<Input>;
private:
	Input();
public:
	bool					Init();
	bool					Frame();
	bool					Render();
	bool					Release();
public:
	void					MSGEvent(MSG);
public:
	bool					isPressAnyKey();
public:
	KEYSTATE				GetKey(DWORD);
	KEYSTATE				GetMouse(DWORD);
	POINT					GetMousePos();
public:
	void					setKey(DWORD);
private:
	KEYSTATE				KeyCheck(DWORD);
private:
	TCHAR					m_csBuffer[256];
	POINT					m_MousePos;
	KEYSTATE				m_KeyState[256];
	KEYSTATE				m_BeforeMouseState[3];
	KEYSTATE				m_CurrentMouseState[3];
};

#define S_Input Input::getInstance()#pragma once
#include "EffectObj.h"


class KahoAttack1 : public EffectObj
{
public:
	bool		Init() override;
	bool		Frame() override;
};

class KahoAttack2 : public EffectObj
{
public:
	bool		Init() override;
	bool		Frame() override;
};

class KahoAttack3 : public EffectObj
{
public:
	bool		Init() override;
	bool		Frame() override;
};

class KahoAirAttack : public EffectObj
{
public:
	bool		Init() override;
	bool		Frame() override;
};

class KahoBowAttack : public EffectObj
{
public:
	bool		Init() override;
	bool		Frame() override;
};#pragma once
#include "TerrainObject.h"

class LadderObject : public TerrainObject
{
public:
	bool		Collision(Object*) override;
	void		ObjectDraw(Object*);
private:
};#pragma once
#include "Std.h"
#include "fmod.hpp"
#include "fmod.h"
#include "fmod_errors.h"

const INT g_iMaxSound = 32;

enum BGM
{
	TITLE = 0,
	STAGE
};

enum Effect
{
	ATTACK1 = 2,
	ATTACK2,
	ATTACK3,
	AIRATTACK,
	ARROW,
	JUMP,
	ROLL,
	MENUCANCLE,
	MENUMOVE,
	MENUSELECT,
	PRESSANYKEY,
	SETTINGMOVE,
	HURT
};

class mSound : public Singleton<mSound>
{
	friend class Singleton<mSound>;
private:
	mSound() {};
public:
	bool				Init		();
	bool				Frame		();
	bool				Render		();
	bool				Release		();
public:
	INT					LoadSound	(const char*, const bool& = false);
	void				Play		(const INT&, const bool& = true, const bool& = false);
public:
	void				StopSound	(const INT&);
	void				PauseSound	(const INT&);
public:
	void				LoadFile	(const char*);
private:
	INT					m_iSoundList;
	FMOD::System*		m_pSystem;
	FMOD::Channel*		m_pCh[g_iMaxSound];
	FMOD::Sound*		m_pSound[g_iMaxSound];
};


#define S_Sound mSound::getInstance()#pragma once
#include "Object.h"

class NPC : public Object
{
public:
	NPC();
	~NPC();
public:
	bool		Frame() override;
private:
	int			m_iDirection[2];
};#pragma once
#include "BitmapMgr.h"
#include "Input.h"

class Rendering;

class Object
{
public:
	Object();
	virtual ~Object() {};
public:
	virtual bool		Init			();
	virtual bool		Frame			();
	virtual bool		Render			();
	virtual bool		Release			();
public:
	RECT*				getrtDraw		();
	RECT*				getCollisionRt	();
	FloatPoint*			getCenterPos	();
	FloatPoint*			getDrawPos		();
	HDC					getColorDC		() const;
	HDC					getMaskDC		() const;
	FLOAT				getSpeed		() const;
	bool				getDebugmode	() const;
	bool				getLanding		() const;
public:
	void				setRendering	();
	void				setRendering	(const FLOAT&, const INVERSE&);
	void				setRendering	(const FLOAT&);
	void				setRendering	(const INVERSE&);
	void				setFadeRender	(const FLOAT&, const FLOAT&);
	void				setFadeRender	(const FLOAT&, const INVERSE&);
	void				setDebugmode	(const bool&);
	void				setSpeed		(const FLOAT&);
	void				setDraw_x		(const FLOAT&);
	void				setCenterPos_x	(const FLOAT&);
	void				setCenterPos_y	(const FLOAT&);
	void				setLanding		(const bool&);
public:
	void				DebugMode();
public:
	virtual bool		LoadFile		(T_STR, T_STR, T_STR = std::basic_string<TCHAR>());
	virtual void		Set				(const FLOAT&, const FLOAT&,
										const DWORD& = 0, const DWORD& = 0, const DWORD& = 0, const DWORD& = 0);
	void				Set				(const FloatPoint&, const RECT&);
public:
	virtual bool		MoveScrollBk	(const LONG&);
	virtual bool		MoveScrollObj	(const LONG&);
public:
	virtual	bool		Collision		(Object *);
public:
	void * operator new(size_t sz, const char* FileName, int iLine);
	void operator delete(void * p);
protected:
	FLOAT				m_fScroll;
	FloatPoint			m_CenterPos;
	FloatPoint			m_DrawPos;
	FLOAT				m_fSpeed;
	RECT				m_rtDraw;
	RECT				m_rtCollision;
	Bitmap *			m_ColorBitmap;
	Bitmap *			m_MaskBitmap;
	bool				isDebugMode;
	bool				isLanding;
	Rendering*			m_pRendering;
};#pragma once
#include "TerrainObject.h"

class OrbObject : public TerrainObject
{
public:
	OrbObject();
public:
	bool		Collision(Object*) override;
	bool		isPlatUP() override;
	bool		Init() override;
	bool		Frame() override;
	bool		Render() override;
	bool		Release() override;
private:
	bool		m_bPlatUp;
};#pragma once
#include "TerrainObject.h"

class PlatObject : public TerrainObject
{
public:
	bool				Init() override;
	bool				Frame() override;
	bool				Render() override;
	bool				Release() override;
};#pragma once
#include "CharacterObject.h"

class Player : public CharacterObject
{
public:
	Player();
	void		setHP(const INT&) override;
};#pragma once
#include "PlayerBasicState.h"

class PlayerAttack : public PlayerState
{
public:
	PlayerAttack(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
	bool		Render() override;
};
class PlayerAttack2 : public PlayerState
{
public:
	PlayerAttack2(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
	bool		Render() override;
};
class PlayerAttack3 : public PlayerState
{
public:
	PlayerAttack3(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
	bool		Render() override;
};
class AirAttack : public PlayerState
{
public:
	AirAttack(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
	bool		Render() override;
private:
	FLOAT		m_fAcceleration;
};
class BowAttack : public PlayerState
{
public:
	BowAttack(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
};
class AirBowAttack : public PlayerState
{
public:
	AirBowAttack(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
private:
	FLOAT		m_fAcceleration;
};
class CrouchBowAttack : public PlayerState
{
public:
	CrouchBowAttack(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
};#pragma once
#include "State.h"
#include "Player.h"

class EffectObj;

class PlayerState : public State
{
public:
	PlayerState(Player*);
public:
	virtual bool		Init() =0;
	virtual bool		Frame() =0;
	virtual	bool		Render();
	virtual	bool		Release();
protected:
	Player *			m_pCharObj;
};
class PlayerIdle : public PlayerState
{
public:
	PlayerIdle(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
};
class PlayerRun : public PlayerState
{
public:
	PlayerRun(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
};
class PlayerBrake : public PlayerState
{
public:
	PlayerBrake(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
};
class PlayerTurn : public PlayerState
{
public:
	PlayerTurn(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
};
class PlayerJump : public PlayerState
{
public:
	PlayerJump(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
private:
	FLOAT		m_fAcceleration;
	FLOAT&		m_fJumpSpeed;
};
class PlayerJump2 : public PlayerState
{
public:
	PlayerJump2(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
private:
	FLOAT		m_fAcceleration;
	FLOAT&		m_fJumpSpeed;
};
class PlayerFall : public PlayerState
{
public:
	PlayerFall(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
private:
	FLOAT		m_fAcceleration;
};
class PlayerRise : public PlayerState
{
public:
	PlayerRise(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
};
class PlayerCrouch : public PlayerState
{
public:
	PlayerCrouch(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
};
class PlayerLadderEnter : public PlayerState
{
public:
	PlayerLadderEnter(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
};
class PlayerLadderLeave : public PlayerState
{
public:
	PlayerLadderLeave(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
};
class PlayerLadderUp : public PlayerState
{
public:
	PlayerLadderUp(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
};
class PlayerLadderDown : public PlayerState
{
public:
	PlayerLadderDown(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
};
class PlayerRoll : public PlayerState
{
public:
	PlayerRoll(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
};
class PlayerHurt : public PlayerState
{
public:
	PlayerHurt(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
};
class PlayerDeath : public PlayerState
{
public:
	PlayerDeath(Player*);
public:
	bool		Init() override;
	bool		Frame() override;
};
#pragma once
#include "Std.h"
#include "Object.h"

class Rendering
{
public:
	Rendering(Object*);
	virtual ~Rendering() {};
public:
	virtual bool		Init		();
	virtual bool		Frame		();
	virtual bool		Render		();
	virtual bool		Release		();
	virtual	void		setInverse	(const INVERSE&);
	virtual	void		setFade		(const FLOAT&, const FLOAT&);
	virtual void		setFix		(const FLOAT&, const FLOAT&);
public:
	void * operator new(size_t sz, const char* FileName, int iLine);
	void operator delete(void * p);
protected:
	FloatPoint*			m_CenterPos;
	FloatPoint*			m_DrawPos;
	RECT*				m_rtCollision;
	RECT*				m_rtDraw;
	HDC					m_hColorDC;
	HDC					m_hMaskDC;
};
class InversionRendering : public Rendering
{
public:
	InversionRendering(Object*, const FLOAT&, const INVERSE&);
public:
	bool				Frame() override;
	bool				Render() override;
	void				setInverse(const INVERSE&) override;
private:
	INVERSE				m_sInverse;
	FLOAT				m_fZoom;
};
class RotateRendering : public Rendering
{
public:
	RotateRendering(Object*, const FLOAT&);
public:
	void				getRotateBitmap(HBITMAP, HDC);
public:
	bool				Init() override;
	bool				Frame() override;
	bool				Render() override;
	bool				Release() override;
private:
	HDC					m_hRotationDC;
	HDC					m_hRColorDC;
	HDC					m_hRMaskDC;
	HBITMAP				m_hbColorBitmap;
	HBITMAP				m_hbMaskBitmap;

	FLOAT				m_fAngle;
	FLOAT				m_fMaxLength;
};
class AlphaRendering : public Rendering
{
public:
	AlphaRendering(Object*, const INVERSE& = INVERSE::DEFAULT, const FLOAT& = 1.0f);
public:
	bool				Init		() override;
	bool				Frame		() override;
	bool				Render		() override;
	void				setFade		(const FLOAT&, const FLOAT& = 30.0f);
public:
	bool AlphaBlend(HDC dcDest, int x, int y, int cx, int cy,
		HDC dcSrc,
		HDC dcMaskSrc, int sx, int sy, int scx, int scy, int alpha, 
		DWORD opMode = SRCCOPY, COLORREF rgbMask = RGB(0, 0, 0));
private:
	INVERSE				m_sInverse;
	BLENDFUNCTION		m_bBlend;
	FLOAT				m_fZoom;
	FLOAT				m_fAlpha;
	FLOAT				m_fFadeSpeed;
};#pragma once
#include "Core.h"
#include "BKObject.h"
#include "SpriteMgr.h"
#include "Player.h"
#include "Scroll.h"
#include "Enemy.h"
#include "TerrainObject.h"
#include "FadeObject.h"
#include "UI.h"

class Scene
{
public:
	Scene();
public:
	virtual bool	Init		() = 0;
	virtual bool	Frame		() = 0;
	virtual bool	Render		() = 0;
	virtual bool	Release		() = 0;
	virtual bool	inverseSet	();
	bool			getNextScene();
public:
	void * operator new(size_t sz, const char* FileName, int iLine);
	void operator delete(void * p);
protected:
	BKObject		m_BKObject;
	FadeObject*		m_pFadeObject;
	bool			m_bNextSceneStart;
};

class LobbyScene : public Scene
{
public:
	LobbyScene();
public:
	bool			Init		() override;
	bool			Frame		() override;
	bool			Render		() override;
	bool			Release		() override;
	bool			BKState		();
	void			PosSet		();
	void			AKeyReact	(const INT&);
protected:
	INT				m_miscIndex;
	LOBBYSTATE		m_state;
	bool			isSoundBar;
	bool			isPress;
	BKObject		m_bkmisc[3];
	RECT			m_miscrt[12];
	FloatPoint		m_miscpos[11];
};

class EndScene : public Scene
{
public:
	bool			Init		() override;
	bool			Frame		() override;
	bool			Render		() override;
	bool			Release		() override;
};

#pragma once
#include "GameScene.h"

class SceneMgr : public Singleton<SceneMgr>
{
	friend class Singleton<SceneMgr>;
	SceneMgr();
public:
	bool			Init		();
	bool			Frame		();
	bool			Render		();
	bool			Release		();
	Scene*			CreateScene	(const INT&, const bool&);
private:
	INT				m_nIndex;
	Scene *			m_pCurrentScene;
};

#define S_SceneMgr SceneMgr::getInstance()#pragma once
#include "Enemy.h"

class ScrollObject;

class Scroll
{
public:
	Scroll(Object * pBkObj, std::list<Enemy*>* npcVector = nullptr);
public:
	bool				Init			();
	bool				Frame			();
	bool				Render			();
	bool				Release			();
	bool				MoveCamera		(const LONG& size);
	bool				MoveCenter		(const LONG& size);
	void				setScene5		(const bool&);
public:
	void				AddScrollObject	(ScrollObject*);
private:
	bool				Collision		(const RECT&);
private:
	bool				m_bScene5;
	std::array<INT,2>	m_nInitValue;
	std::list<Enemy*>*	m_npclist;
	Object*				m_pPlayer;
	Object*				m_pBkObj;
	ScrollObject*		m_pScrollObject;
	RECT*				m_PlayerCollisionRt;
	RECT*				m_BkRtDraw;
	FloatPoint			m_CenterPos;
	RECT				m_rtCollision;
};#pragma once
#include "TerrainObject.h"

class ScrollObject : public TerrainObject
{
public:
	bool				Init() override;
	virtual bool		Frame() override;
	bool				Render() override;
	bool				Release() override;
	virtual	bool		MoveObject(Object*, const RECT&);
	virtual bool		Collision(Object*) override;
	void				ReverseSet(const LONG&);
};#pragma once
#include "Std.h"

using SPRITELIST = std::vector<RECT>;

class Sprite
{
public:
	Sprite(const int&);
	~Sprite();
public:
	void * operator new(size_t sz, const char* FileName, int iLine);
	void operator delete(void * p);
public:
	bool				Init			();
	bool				Frame			();
	bool				Render			();
	bool				Release			();
public:
	RECT				getSpriteRt		();
	bool				setDivideTime	(const FLOAT&);
	bool				setIndex		(const INT&);
	INT					getIndex		();
	bool				setList			(const SPRITELIST&);
	size_t				Size			();
private:
	INT					m_iIndex;
	FLOAT				m_fDivideTime;
	FLOAT				m_fSpriteTime;
	FLOAT				m_fOffset;
	SPRITELIST			m_spritelist;
};
#pragma once
#include "Sprite.h"
#include <fstream>
#include <sstream>

using SPMAP = std::map<std::string, Sprite*>;
using TSPMAP = std::map<std::string, SPMAP>;

class SpriteMgr : public Singleton<SpriteMgr>
{
	friend class Singleton<SpriteMgr>;
public:
	~SpriteMgr();
public:
	bool				Init		();
	bool				Frame		();
	bool				Render		();
	bool				Release		();
public:
	bool				SpriteSet	(T_STR);
	Sprite*				LoadSprite	(T_STR, T_STR);
private:
	TSPMAP				m_SpriteMap;
};


#define S_SpriteMgr SpriteMgr::getInstance()#pragma once
#include "SpriteMgr.h"

class CharacterObject;
class EffectObj;
class Player;

class State
{
public:
	State(CharacterObject*);
public:
	virtual bool		Init		() = 0;
	virtual bool		Frame		();
	virtual bool		Render		();
	virtual bool		Release		();
	virtual bool		Process		(Player*);
public:
	void				setSprite	(T_STR, T_STR);
public:
	RECT				getEffectRT	();
public:
	void * operator new(size_t sz, const char* FileName, int iLine);
	void operator delete(void * p);
protected:
//	CharacterObject *	m_pCharObj;
	Sprite *			m_pSprite;
	FloatPoint*			m_CenterPos;
	RECT*				m_rtDraw;
	EffectObj *			m_pEffectObj;
	FLOAT				m_fTimer;
};
#pragma once
#include <windows.h>
#include <cassert>
#include <tchar.h>
#include <string>
#include <list>
#include <vector>
#include <map>
#include <cstdlib>
#include <cmath>
#include <sstream>
#include <fstream>
#include <array>

#pragma comment(lib,"winmm.lib")
#pragma comment(lib,"msimg32.lib")
#pragma comment(lib,"MomodoraLibrary.lib")
#pragma comment(lib,"fmod64_vc.lib")


#define New new(__FILE__,__LINE__)
#define PI 3.141592
#define DegreeToRadian(x) (x) * PI / 180.0f

struct MEMINFO
{
	std::string  filename;
	INT			 line;
	DWORD		 dwAllocateTime;
	void*		 addr;
};

using T_STR = std::basic_string<TCHAR>;
using MEM_MAP = std::map<void *, MEMINFO>;
using RECT_VECTOR = std::vector<RECT>;

enum class KEYSTATE : unsigned char
{
	KEY_FREE,
	KEY_PUSH,
	KEY_HOLD,
	KEY_UP
};
enum class SCENE : unsigned char
{
	LOBBY,
	GAME,
	END
};
enum class INVERSE : unsigned char
{
	LR_ROTATION,
	TB_ROTATION,
	LRTB_ROTATION,
	DEFAULT
};
enum class LOBBYSTATE : unsigned char
{
	DEFAULT,
	START,
	MAINMENU,
	SETTING,
	KEYSETTING,
	SELECT
};

template <typename K>
class Singleton
{
protected:
	Singleton() {};
public:
	static K& getInstance()
	{
		static K inst;
		return inst;
	}
};

struct FloatPoint
{
	FLOAT x, y;
};
struct Sphere
{
	FLOAT fRadius;
	POINT CenterPos;
};
struct FloatRect
{
	FLOAT left, top, right, bottom;
};


extern HWND					g_hWnd;
extern HINSTANCE            g_hInstance;
extern HDC					g_hOffScreenDC;
extern HDC					g_hScreenDC;
extern RECT					g_rtClient;
extern float				g_fSpeed;
extern float				g_fSecPerFrame;
extern bool					g_bActiveApp;

extern INT					g_HP;
extern INT					g_iNewCount;
extern MEM_MAP				MemoryMap;
extern FLOAT				g_EffectVolume;
extern FLOAT				g_BGMVolume;

class UI;

extern UI *					g_UI;
extern UI *					g_HPBar;

class Player;

extern Player*				g_pPlayer;

//	KahoAttack1 7
//	KahoAttack2 7
//	KahoAttack3 11
//	AirAttack 7
//	LandAttack 7
//	Leaf1 7
//	Leaf2 7
//	Leaf3 9
//	AirLeaf 6
//	Bow 6
//	Airbow 6
//	CrouchBow 6
//	Run 10
//	Brake 7
//	Turn 3
//	Crouch 4
//	Rise 2
//	Death 24
//	Defensive 3
//	EndingDeath 35
//	EndingDeath2 28
//	Jump  3
//	Fall 5
//	ToPraying  6
//	Praying 4
//	FromPraying 9
//	HeadBob 4
//	HeadBobBack 4
//	Hurt 1
//	Idle 6
//	Look 14
//	Item 11
//	LadderUp 6
//	LadderDown 3
//	LadderEnter 6
//	LadderLeave 6
//	Roll 8
//	MiscEffect 3
//	Shine 1
//	Icon 1
//	ArrowS 1
//	ArrowL 1#pragma once
#include "Object.h"
#include "Player.h"
#include "Collision.h"

class TerrainObject : public Object
{
public:
	bool				Init			() override;
	virtual bool		Frame			() override;
	bool				Render			() override;
	bool				Release			() override;
	virtual	bool		MoveObject		(Object*, const RECT&);
	virtual bool		Collision		(Object*) override;
	void				ReverseSet		(const LONG&);
	virtual bool		isPlatUP		();
};#pragma once
#include "Std.h"
class Timer
{
public:
	Timer();
public:
	bool					Init();
	bool					Frame();
	bool					Render();
	bool					Release();
private:
	TCHAR					m_csBuffer[256];
	float					m_fSecPerFrame;
	float					m_fTimer;
	float					m_fGameTime;
	DWORD					m_dwBeforeTick;
	DWORD					m_dwFrameCount;
	DWORD					m_dwInterval;
};#pragma once
#include "TerrainObject.h"

class TrapObject : public TerrainObject
{
public:
	bool		Collision(Object*) override;
private:
};#pragma once
#include "Object.h"

class UI : public Object
{
public:
	bool		MoveScrollObj(const LONG&) override;
private:

};#pragma once
#include "Std.h"
#include "Input.h"

LRESULT	CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);

class Window
{
public:
	Window();
public:
	bool					SetWindow(HINSTANCE, LONG, LONG);
	bool					Run();
public:
	virtual bool			GameInit();
	virtual bool			GameFrame();
	virtual bool			GameRender();
	virtual bool			GameRelease();
	virtual bool			Init();
	virtual bool			Frame();
	virtual bool			Render();
	virtual bool			Release();
private:
	void					CenterWindow();
private:
	HINSTANCE				m_hInstance;
	RECT					m_rtClient;
	RECT					m_rtWindow;
	HWND					m_hWnd;
};